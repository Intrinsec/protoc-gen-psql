CREATE OR REPLACE FUNCTION {{ .CreateFunctionName }}()
	RETURNS boolean
	LANGUAGE plpgsql
AS $fn_create_trigger$
DECLARE
	dst_table_name TEXT;
	dst_pk_column_name TEXT;
BEGIN
	SELECT
		kcu2.table_name,
		kcu2.column_name INTO dst_table_name,
		dst_pk_column_name
	FROM
		information_schema.key_column_usage AS kcu
		INNER JOIN information_schema.referential_constraints AS rc ON rc.constraint_name = kcu.constraint_name
		INNER JOIN information_schema.key_column_usage AS kcu2 ON kcu2.constraint_name = rc.unique_constraint_name
	WHERE
		kcu.table_name = lower('{{ .RelationTable }}')
		AND kcu.column_name = '{{ .ForeignKey }}'
		AND kcu.constraint_name LIKE '%_fkey';

	EXECUTE FORMAT($format_function$
		CREATE OR REPLACE FUNCTION {{ .FunctionName }}()
			RETURNS trigger
			LANGUAGE plpgsql
		AS $$
		BEGIN
			IF (TG_OP IN ('DELETE', 'UPDATE')) THEN
			{{- range $Update := .Updates }}
				UPDATE %1$I SET {{ $Update.Field }} = {{ $Update.Value }} WHERE %2$I = OLD.{{ $.ForeignKey }};
			{{ end -}}
			END IF;
			
			IF (TG_OP IN ('INSERT', 'UPDATE')) THEN
			{{- range $Update := .Updates }}
				UPDATE %1$I SET {{ $Update.Field }} = {{ $Update.Value }} WHERE %2$I = NEW.{{ $.ForeignKey }};
			{{ end -}}
			END IF;

			RETURN NULL;
		END
		$$;
	$format_function$, dst_table_name, dst_pk_column_name);

	DROP TRIGGER IF EXISTS {{ .TriggerName }} ON {{ .RelationTable}};

	CREATE TRIGGER {{ .TriggerName }} AFTER INSERT OR DELETE OR UPDATE ON {{ .RelationTable }} FOR EACH ROW EXECUTE FUNCTION {{ .FunctionName }}();

	RETURN NULL;
END
$fn_create_trigger$;

SELECT {{ .CreateFunctionName }}();
